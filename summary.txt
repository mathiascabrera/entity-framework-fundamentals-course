Discover Entity Framework, a modern ORM designed for .Net with a project to add to your portfolio. Connect to a database and create the models using the Fluent API.


connection to database and creation of models with Entity Framework.

Create "Task" and "Categories" models with Entity Framework and connect your .NET project to a real database. Learn how to use the minimal API template.



" INTRODUCTION "



--------------------  Presentation  --------------------

Let's learn how these components work in .NET that will allow connection to the database.

We will begin to analyze the different concepts that Entity Framework uses for its operation.

Then we will see two ways in which we can use Entity Framework either with Attributes or Fluen API.

To make this configuration and learn how Entity Framework works, we are going to create two models. A Category model and another Task model. Both will be related, allowing us to analyze how Entity Framework creates relationships between different tables when we make this relationship in models and in Entity Framework configuration.

Later we will connect this configuration that we created to a real database and then finally we will learn how we can perform the different actions with the data (get, create, update and delete data), using Entity Framework.


https://designer.mocky.io/
https://insomnia.rest/

--------------------------------------------------------





--------------------  Database Connection  --------------------

We will see how we can connect an application to a database and the different types of mechanisms that exist in .NET to achieve this.

Normally in an application we will have a “Client” component that will be used by the “End User” which we call “Frontend” in the case of web applications or in an App that runs on a cell phone. And this Client is going to have to connect to a “Backend” that will finally be running on a Server and is the one that would connect to the Database.

Why is a process normally done this way?
The reason is that the Client should not connect directly to the Database, because in the end to make this connection we will need different components, different libraries and also secrets, that is, passwords and others that will allow us to connect to the database. And this data will finally be in the Client and this end user will be able to access it. So normally a user who doesn't know much about computers won't know what's going on underneath; However, any user with even minimal knowledge of technology will be able to see inside the client, inspect the code, and figure it out. that there is data to access. the database and make any changes that have not been requested and be able to bypass all the security, authentication and authorization problems that we have in our applications. For this reason, the connection to the DB must be made from the Backend.

The Backend runs within an external Server to which the Client does not have access and in order to access the Backend they will have to use the Frontend which will have a large part of the administration of roles and permissions and so on. This way we have a secure channel to save and update data in our application.

Generally this is the Architecture that we must create in a real Application.
In this course we are going to focus on the Backend part.

Entity Framework is responsible for simplifying how we build the Backend to be able to connect to the DB.


There are different types of components that we can use to connect to the DB:

In Windows, the ODBS and OLEDB components are normally used. These are drivers that we install on our machines and then through a connection “string” we can connect to a Database and obtain the information we need.


Microsoft created a specific element to connect to its database engine which is "SQL Server", and also created a specific one for "Azure SQL", this connection with Azure is a very advanced connection, much more secure that even includes certificates , includes the IP of the computer we are on, and in this way a more secure protocol is generated.


In the end all these types of connections are the same. It is having a connection string that we have to configure to then be able to access the server where the DB is located and manipulate the data using SQL commands.

In this course "SQL Server" will be used.


Within .NET we have a component that allows us to make all these connections to the DB that we just saw. This component is known as ADO.NET.

ADO.NET is a set of different libraries that allow us to access databases and also data services.
Basically we can not only access a database like SQL Server but we can also access slightly simpler databases like ACCES or even EXCEL files.


ADO.NET is a library that has been evolving year after year and has more and more options to connect us and carry out that interaction between our Backend and the Database.


We can see in the image of “ADO.NET Operation” that no matter the provider or the type of connection we are using, ADO.NET is in charge of managing that connection, bringing the data from that data source that we are using and that we can use inside our .NET application.

It doesn't matter the type of application, it can be a web or desktop application or a simple library, so it doesn't matter what we are doing with .NET since in the end everything has to go through ADO.NET in order to make the connection.

We can see at the bottom of the image the different data sources: DB SQL as well as NOSQL, REST services, we can have a simple EXCEL file and with ADO.NET we can connect to this file and get the data.



In the end, when we want to use the data obtained by ADO.NET, we can use different means to process it: We have the "DataSets" (they fill in all the information that we take from the DB to a generic component that we will then consult row by row and column by column ), we also have "LINQ to SQL" (it is a component that is not used much anymore), and finally the most popular means that exists in .NET so far, that is, connecting to an "Entity Framework".


In the next class we will learn the most important concept that we are going to learn since it is the basis of Entity Framework: ORM


--------------------------------------------------------------------





--------------------  What is an ORM in programming?  --------------------

We learn a concept that is the basis of the operation of the Entity Framework known as ORM.


" CHALLENGES WHEN CONNECT ABASE "

- Scheme maintenance:

One of the most important challenges when working with a Database is maintaining the schema that we have created and that we are constantly modifying.

We must maintain traceability of all the modifications we make. For example when adding new columns or when we change the data type of a column. Maintaining traceability of this data becomes a bit complex.

Normally, we must be creating SQL Scripts that are responsible for making these changes and somehow perform all the traceability of these changes manually. For example, it could be creating a repository on GitHub and naming each of the scripts that we have created and maintaining the history of all those scripts.

This is one way to do it but it is complex and additional that we must do and is not directly related to the Backend. However, we must do it and have it available to be able to understand the changes that have been made over time and if at some point we must return to a change, make it possible in a simple way.


- Creating SQL queries :

SQL is another programming language like any other, so a Backend programmer will not only have to learn JavaScript or C# but will also have to learn this SQL language to be able to communicate with the database.
This is really not a problem, since after learning SQL we can perform this communication. That is, data extraction can be done using this language. However, for new developers it is a challenge as they have to learn an additional language to be able to perform this communication.


- Data transformation to be used in the Backend :

Another important challenge is to transform the data provided by the database to be able to use it in the Backend language that we are using.
Typically, in C# and Java, for example, we use a lot of object-oriented programming and we also use strongly typed data.
The data we handle within a programming language is not the same as the data supported by the databases, so we must perform a transformation so that this data matches and we can use it.


- Ensure security when handling data :

Another challenge is security.

There is a well-known type of database hacking known as “SQL INJECTION”.
Basically, malicious SQL scripts are sent to the server from a client application and executed maliciously to make some unexpected change or delete data from the database.

In order to control this type of situations we can use different libraries and database engines, since they have controls for this. However, ORMs are the most important components to avoid this since internally they have quite advanced control for this type of situation. So due to the security issue we are also going to have several challenges and thanks to the ORMs we will be able to control many of these difficulties.



What is ORM? :

Its acronym stands for Object Relational Mapping.

The concept of Mapping is well known in the world of software development.
When we talk about mapping, basically what we do is look for the representation of one component in another.

It is simply a connection between a component of one type with another component of a completely different type.

So, basically the ORM allows us to convert components that come from the Database to a much friendlier type, much more used within our code.

When mapping, there is basically a relationship between one and the other. In turn, each change we make within these components, from our code, will be reflected in the database.


ORMs are based on object-oriented programming to perform this mapping that we mentioned above.

We use the concept of Classes and Objects to be able to communicate with the columns, tables and data of the Database.

So basically we will make this representation that exists of a table in the Database using a Class and each of the attributes and properties of this Class will represent a column within the Database.

So this is what mapping consists of, it is that representation of code components or pieces of code that we normally use in our daily lives that are much easier to understand and work within programming languages ​​to be able to easily communicate with the database. data.


We must also understand that there are different functions or query languages ​​that exist within the code in order to replace SQL.
In the case of Entity Framework, for example, different extension functions are used and also an important component called LINQ within .NET to be able to replace what the SQL language would normally do.


There are multiple ORMs, it is a concept well known to many programmers regardless of the programming language. This programming language must be object-oriented.

Some of them can be :

- Hibernet.
It is one of the most important ORMs in the world and is used with the JAVA programming language.

- Dapper.
It is a fairly well-known ORM within .NET.
Its advantage over Entity Framework is that it is completely OpenSource that is supported by the community and also has some very simple things when it comes to implementation.
However, when we have slightly more advanced and complex examples within our application, the app may fall short in some aspects to be able to achieve what we want to implement and it may be a bit complex to do so.

- NHibernate.
A version for .NET.
It is exactly the same as Hibernet for JAVA, but in this case for the C# and .NET language.

- Django ORM.
Quite popular ORM for Python, however, Python has several other ORMs.


All these ORMs have the same principles for performing the mapping that we have mentioned, however, the configurations and functions for performing the connections are different.


More information about SQL injection:

https://www.w3schools.com/sql/sql_injection.asp


To understand how a SQL injection attack works and how to protect yourself, do this exercise:
https://www.hacksplaining.com/exercises/sql-injection


---------------------------------------------------------------------------





--------------------  Introduction to Entity Framework.  --------------------

Entity Framework is an open source ORM for .NET.
This means that it uses this mapping idea we talked about earlier from a database to C# OR Visual Basic or F# code.

Entity Framework uses the ADO.NET library to make the entire connection from .NET to the database.
We don't have to do any configuration as Entity Framework is configured internally. This allows us to have compatibility with many databases and also have a fairly stable and fast connection with the different databases.


Just as there are two versions of .NET: .NET Framework and .NET Core, there are also two versions of Entity Framework: Entity Framework and Entity Framework Core.

However, lately the word Core has been dropped as all new applications use .NET or the latest version of .NET.

Existen algunas diferencias entre una versión del framework y otra.


What are the advantages of using Entity Framework?

- We don't have to "map" every piece of data we get from the database to C# code.
By avoiding this we are saving significant time in the implementation and execution of the application.

- It allows us to manage a single repository for Backend and database.
In this repository we can add all the changes we are making to the database and all the components we will need to connect to the database.
We don't have to go directly to the database to make changes or create components within the database.

- With Enity Framework we improve security, we practically do not have to do anything and we will be sure that Entity Framework will carry out very good security management.

- It is much friendlier to work with Entity Framework than to work with a direct component like ADO.NET, SQL language and connection to the database.
With Entity Framework we only handle the language we are using, in this case C#, and from this language we solve any problem with the database or make any modifications to the database.

- It allows us to control the history of database changes in a very simple way.
Databases frequently need new columns and tables and we must control all changes, that is, have the history that is being developed so that we can return at some point if necessary.
Entity Framework offers us a functionality called “MIGRATIONS”, which we will see later and we will be able to understand how we can do this in a very easy way without having to complicate our lives using “SQL scripts” and “versioning”. And additionally a repository to control the history of changes.

https://learn.microsoft.com/es-es/ef/core/what-is-new/


---------------------------------------------------------------------------





--------------------  Creating a .NET project with Entity Framework   --------------------

We are now ready to analyze the project we are going to work on during the course.

In this project we will have the possibility of creating different tasks.
In turn, we can assign each of these “Tasks” a “Category”.

We will use the .NET "Minimal API" template.
This template allows us to create APIs without having many configuration files or many components.

From the terminal we execute 'dotnet new web' to create the template.

We must download the necessary libraries to work with Entity Framework.
To do this we go to the NUGET site and search for "EntityFrameworkCore".
We are going to install it using the command that ".NET CLI" provides us.
It is not recommended to install the "preview" version.
We must paste the copied command into the Visual Studio terminal.

Once this command is executed, the library will have been installed.
To verify we must open the file with the extension "csproj".


We will install other additional packages using the CLI.

We search in NUGET for "EntityFrameworkCore.InMemory".
This package will help us create an in-memory database and be able to test the model we are creating within .NET using Classes and Attributes.

Finally we search for "EntityFrameworkCore.SqlServer".
This library will allow us to connect to the SQL Server database engine.
If we want to work with Postgres we must search for “EntityFrameworkCore.PostgreSQL”.

In the next class we will create the “Task” and “Category” models that will be the bases for creating our tables in the database.


---------------------------------------------------------------------------------------------


" INITIALIZATION WITH ENITY FRAMEWORK "


--------------------  Model Creation   --------------------

In this class we are going to create the Models and Classes that will end up being Tables in the Database.

We create a new folder “Models” to store our Models.
Inside this folder we create our two models: the Category class and the Task class.
In each of these classes we define each of the attributes or columns of each Table in the database.

In the next class we are going to configure Entity Framework to connect to the database.

-----------------------------------------------------------





--------------------  Entity Framework Configuration   --------------------

We have already created the Models, which are the bases of the Database Tables.

In this class we will learn how to configure Entity Framework to establish relationships.

Normally we must create a "Context" where all the relationships of the "Models" will be stored in order to transform them into Collections that will be represented in the database.

We could create a folder for the Context, but since it is not a large project we directly create a Class.

Normally the name of the Context Class is that it has the name of the application or the name of the business to which we are connecting at the database level and at the end the word “Context”. For example: TasksContext.cs

The Context class must inherit from the DbContext class. DbContext has all the components our class needs to create the database configuration.




Context: It is where all the relationships of the models we have will go to transform them into collections that will be represented within the database.

https://learn.microsoft.com/es-es/ef/ef6/fundamentals/working-with-dbcontext#defining-a-dbcontext-derived-class


DBSet: It is a set or assignment of data from the model that we have previously created, basically this will represent what a table would be within the context of the entity framework.

A DbSet represents the collection of all entities in the context, or queryable from the database, of a given type. DbSet objects are created from DbContext using the DbContext method. place. Microsoft offers us more information about this class at the following link: https://learn.microsoft.com/es-es/dotnet/api/system.data.entity.dbset-1?view=entity-framework-6.2.0


---------------------------------------------------------------------------





--------------------  Model mapping using attributes   --------------------

In the previous class we have configured Entity Framework, now we can create the database. However, there are attributes or better known as “data annotations” within .NET. Using them helps us configure the different properties of the Models in a more strict and specific way. These attributes will become columns in the database.


Let's start with the Category model.
Entity Framework automatically detects the property or attribute that corresponds to the ID. This is based on two aspects: the first is that the property name ends in Id and the other aspect is that the property name is the same as the Model or class name.
However, we can select which property or attribute of the model we want the ID to be. To do this we must use the reserved word “key”. This declaration should be placed above the attribute that we want to be the ID. In this case we place it above "CategoryId":

[Key]
public Guid CategoryId{get;set;}

To set a required attribute we must use the reserved word "required".

To restrict the number of characters in an attribute we must use the "MaxLength()" instruction.

To set foreign keys we must use the "ForeignKey("NameOfForeignKey")" statement.

To establish that certain properties should not be created in the database we must use the "NotMapped" statement. This way, when mapping our context (with the models) to the database, all properties that are "NotMapped" will be ignored.

In the next class we are going to generate our model within a database.


Sources:
https://learn.microsoft.com/en-us/ef/ef6/modeling/code-first/data-annotations

https://stackoverflow.com/questions/5446316/code-first-vs-model-database-first


------------------------------------------------------------------------------





--------------------  Using in-memory database   --------------------

With what we have done so far we are ready to connect to a real database. However, in this class we will first connect to an in-memory database.
We are going to do this to verify that everything we implement works correctly.

Entity Framework is capable of connecting to a database and creating a schema or tables.

Now we go to VSCode to configure the in-memory database. To do this we open the file "Program.cs" and before that the "var app=builder.Build();" we must perform the configuration. That is, we need to configure it before the application is created and starts listening to requests.


In the next class we will connect to a real database.

lambda:
https://learn.microsoft.com/es-es/dotnet/csharp/language-reference/operators/lambda-expressions

hoppscotch:
https://hoppscotch.io/


---------------------------------------------------------------------------





--------------------  Connected to SQL Server database   --------------------

We have already connected Entity Framework to an in-memory database. This connection was successful. This means that the settings for the "Models" and for the "Entity Framework" are working correctly. Now let's connect Entity Framework to a real database. In this case we will use SQL SERVER.

To do this we must perform the following configuration:

builder.Services.AddSqlServer<CONTEXT>("Data Source=NAME-SERVER-LOCAL; Initial Catalog=NAME-DATABASE;user id= NAME-LOGIN-SQL;password=PASSWORD-SQL");

In SQL SERVER, the authentication must be "SQL Server Authentication".

If we have an error with the "/" character we simply have to duplicate it: "//".


Once this configuration is done, we execute the "dotnet run" command from the VSCode console and open Postman to consume the same Endpoint again that we did in the last class. This Endpoint must return False since the database will not be created in memory but in SQL SERVER.

After consuming the Endpoint, we open SQL MANAGEMENT, the server type must be “Database Engine” and the Authentication “SQL Server Authentication”. When we make the connection we can see that the database was successfully created with the tables and attributes that we created in C#.

We can observe that the "Priority" attribute of the "Tasks" table in SQL SERVER takes it as INT. Remember that in C# we had declared this as ENUM. Each value inside the Priority enumeration in C# is an integer value starting from zero. For example, low would be 0, medium would be 1, and high would be 2. Entity Framework then takes these ENUM values ​​that we declared in C# and represents them as an integer (INT) value within the database. This is one of the magical things about Entity Framework and one of the reasons to use this .NET ORM.

In this process we have added the database connection directly in the code. This is not a good practice because if we wanted to change this address we would have to go to the code and leaving this type of sensitive information inside the code is not good. Next class we will see how we can make this connection in the application configuration file "appsettings".

SQL SERVER installation :
https://www.youtube.com/watch?v=YOaC_TyOrdk&ab_channel=CódigosdeProgramación-MR

The Connection Strings Reference:
https://www.connectionstrings.com/

Other Sources:
https://dbeaver.io/


-----------------------------------------------------------------------------





--------------------  Adding connection to appsettings file   --------------------

Everything we have learned so far also applies to Postgres SQL. To do this we must change some configurations and obviously change the Connection Strings that contain all the security and server name among other data necessary to make the connection to the database.

In the last class we created Sting Connections within the code. If we were in a production environment it would be very difficult to modify these String Connections.

In this class we will learn how we can add this connection to the "appsetting" file and this way our application will be configurable when we move to a production environment.


https://www.connectionstrings.com/sql-server/


Safe storage of app secrets in development in ASP.NET Core:
https://learn.microsoft.com/en-us/aspnet/core/security/app-secrets?view=aspnetcore-6.0&tabs=windows

Fluent API:
https://www.learnentityframeworkcore.com/configuration/fluent-api

User Secrets en ASP.NET Core:
https://medium.com/@rvazquezmiguel/user-secrets-en-asp-net-core-1796dc143506


https://learn.microsoft.com/en-us/dotnet/csharp/


--------------------------------------------------------------------------------------


USING FLUENT API


--------------------  Introduction to Fluent API   --------------------

In some complex cases the attributes will not be enough and we will need to do more complex things where we will have to go directly to the Entity Framework to perform this configuration.

To avoid this, Entity Framework has another way to configure allowing us to have control of many advanced scenarios where attributes or "data annotations" are not supported.

Fluent API is one of the most used techniques in Entity Framework to design our databases.

Fluent API is an advanced way to configure Entity Framework Models without using attributes or "data annotations", allowing you to design the database considering advanced aspects.

Nested extension functions are used to configure tables, columns, and specify data mapping.


Source:
https://learn.microsoft.com/es-es/ef/ef6/modeling/code-first/fluent/types-and-properties


-----------------------------------------------------------------------





--------------------  Creating Category model with Fluent API   --------------------

Let's start seeing how Fluent API works with the "Category" model.

The fluent API takes precedence over attributes or "data annotations."

In this way we have used the Fluent API functions to replace the attributes or data annotations within our Model.




Sources:


https://learn.microsoft.com/en-us/ef/core/modeling/relationships?tabs=fluent-api%2Cfluent-api-simple-key%2Csimple-key

https://learn.microsoft.com/es-es/ef/ef6/modeling/code-first/fluent/relationships

One-to-Many Relationships
https://www.entityframeworktutorial.net/efcore/configure-one-to-many-relationship-using-fluent-api-in-ef-core.aspx

One-to-One Relationships
https://www.entityframeworktutorial.net/efcore/configure-one-to-one-relationship-using-fluent-api-in-ef-core.aspx

Many-to-Many Relationships
https://www.entityframeworktutorial.net/efcore/configure-many-to-many-relationship-in-ef-core.aspx


------------------------------------------------------------------------------------





--------------------  Creating Task model with Fluent API   --------------------

In the next class we will see if the database is created correctly.


------------------------------------------------------------------------------------





--------------------  Connecting to the database with Fluent API   --------------------

We have configured the two models using Fluent API.

In the next class we will learn another functionality that Entity Framework has.
It is very common to make changes to existing tables. How can we keep track of the modifications that are being made to the database?
To do this, Entity Framework has a functionality called “Migrations”.
Migrations will allow us to keep track of the modifications that were made to the database.

------------------------------------------------------------------------------------





--------------------  What's the Migrations?   --------------------

We managed to configure the "Task" and "Category" models using the Fluent API.

It is normal to modify an already created database. How can we have a history of all the modifications made to the database?

Migrations are a feature of Entity Framework that allows us to save all the changes made to the database. This allows us to know when one change depends on another since we have a sequence of changes made.

Migrations allow us to build a version of the database, allowing us to know which database to work with at the code level. We will have a version of our code that will connect to a specific version of the database.

To use it we must install a tool within the DOTNET CLI that will allow us to add a series of commands to manipulate the changes that are being made to the code.


- To add a Migration : dotnet ef migrations add InitialCreate

It will perform an analysis of all changes within the Fluent API or the Attributes, depending on the model we use. It will then generate a Script detailing the changes that were made.

- dotnet ef database update
Updates the database and forces all migrations to run.

- dotnet ef database update



In the next class we are going to implement Migrations and in turn we are going to make our first database script.

- Sources:
Migrations:
	https://learn.microsoft.com/en-us/ef/core/managing-schemas/migrations/?tabs=dotnet-core-cli

Temporal Tables:
	https://learn.microsoft.com/en-us/sql/relational-databases/tables/temporal-tables?view=sql-server-ver16


------------------------------------------------------------------------------------





--------------------  Initialize Migrations   --------------------

In this class we are going to implement Migrations in our project.

We go to VSCode and from the terminal we write "dotnet ef" to verify that we have the "dotnet ef" tool installed. If it is not installed we must search for it on Google. We enter the official Microsoft page where the following two links will appear:

To install it globally on our computer :

dotnet tool install --global dotnet-ef


To update it:

dotnet tool update --global dotnet-ef


We copy the link to install it, paste it and run it in the VsCode console.

With the "dotnet ef" command we can verify that the installation has been completed correctly.

Let's create our first Migration!.

This first Migration is usually called:
"Init database" or "Initial Create"

After the first Migration, each change we make will be given a name that describes the changes made.


To start our Migration we will execute the command:
"dotnet ef Migrations add InitialCreate"


If we receive the following in response:
Your startup project 'project_EF' doesn't reference Microsoft.EntityFrameworkCore.Design. This package is required for the Entity Framework Core Tools to work. Ensure your startup project is correct, install the package, and try again.
We must install the package: "Microsoft.EntityFrameworkCore.Design" from NUGET.


Once the Entity Design is installed, we execute the command again "dotnet ef Migrations add InitialCreate".

Once we initialize the Migration, the “Migrations” folder will be created by default. In this folder there are different classes that contain the Entity Framework configurations that we have.

Inside the file "TasksContextModelSnapshot.cs" we can see that it contains the current database configuration. It contains the same thing we have done with the Fluent API.

The file "20240422224000_InitialCreate.cs" contains all the initial configuration of our database.

Every time we create a Migration we will have an "Up" method and another "Down" method. The "Up" method is executed when the Migration is created or the database is executed. The “Down” method will allow us to reverse the changes we have made in said Migration. In this way the database would be in the version prior to the changes made.


After creating our Migration, we must create our Database again. To do this we must first delete the one we had already created and create it again.

Note: If we want to use Migrations in production, we should use it after we have finished the schema or base configuration of our database. And from now on use Migrations every time we make changes to the database. It is very difficult to use Migrations when our project is already in production and the data already exists within the database.


As we said before, we must delete the database that we had already created. To do this we must open SQL Server and delete the corresponding database.

Once the database is deleted, we execute the "dotnet ef Database update" command in the VSCode console.
This command is the one we are going to execute every time we add a Migration. This command runs all the Migrations to create the different elements contained in the database. And if the database does not exist, it will create it.


Once the command is executed, we open SQL Server and we can see that the database was created correctly.

Unlike the previous database, a new table now appeared: "__EFMigrationsHistory". This table contains the different migrations, that is, the different changes that have been made. To see it we can right click on the table and select the option "Select the top 1000 rows" which will show us all the migrations.

In the next class we are going to create a new Migration, in which we are going to make changes to the existing tables.


------------------------------------------------------------------------------------





--------------------  Creating a Migration   --------------------

In the previous class we have created our Migration using Entity Framework.

We create the initial Migration that contains all the configuration of our Task and Category Models with their validations in Fluent API.

In this class we are going to simulate that we must modify a database that has already been created and is in production. For which, we are going to add a new field in the Category table and then perform a Migration to track the changes made.

We open our Visual Studio and add the "EffortLevel" field. Then we must open “TaskContext” and add the field.

Finally we open the terminal and execute the command "dotnet ef migrations add message".
Remember that the message must be descriptive of the changes made.

Entity Framework will automatically detect changes made since the last migration.

If we execute the command the new migration will be created. We can see that two new files will appear in the "Migrations" folder:

20240517114601_ColumnEffortLevel.Designer.cs
20240517114601_ColumnEffortLevel.cs

The first 8 digits correspond to the date the migration was performed.

An interesting detail is that these files are ordered from the first migration performed to the last.

Once again, if we open these files we will see the two methods that we mentioned above. The Up and Down method. These help us go to the previous migration or return to the current one. The Up method creates the table, that is, it helps us return to the current migration, while the Down method deletes the table, taking us to the previous migration.

So far we created the migration, but we haven't updated our database. To do this we must execute the “dotnet ef database update” command.

If we open SQL Server we can see the modifications we have made.


We will perform the same steps to add a new field in the Task table.


In the next class we will see how we can add initial data to the database.

So far we have only made modifications to the database schema, that is, adding tables and columns. But we can also add initial data in each of the tables. In this way we can carry out a migration that carries out the changes made to this data.

Source:
https://learn.microsoft.com/en-us/ef/core/managing-schemas/migrations/?tabs=dotnet-core-cli


------------------------------------------------------------------------------------





--------------------  Add seed data   --------------------

In this class we are going to create records that will be automatically created in the database.

We add records to Task and Category

We use "GUID.Parse()" to convert a string representing a Guid. We can obtain the string through the following link:
link:https://www.guidgenerator.com/

The reason we don't use "Guid.NewGuid()" is that every time we update the database, the ID will be changed.

Once the changes have been made, we execute the already known commands to add a new migration and then update the database.

In the next class we are going to obtain, modify and delete data from Entity Framework.


------------------------------------------------------------------------------------





--------------------  Getting data with EF   --------------------

So far we have managed to design a database using Entity Framework. In turn, we have taken: the two alternatives, using "data annotations" and "fluent API". We also learned how to create Migrations.

In this class we will learn how to obtain records from databases.

In "Category.cs" we add [JsonIgnore] to the Tasks property so that it ignores this field when we get tasks with their respective categories. If we don't do this we enter an infinite loop.


In the next class we will see how we can insert records into the database.


------------------------------------------------------------------------------------





--------------------  Save data with Entity Framework   --------------------

To add data to the database we must use "POST".

Once the project has been executed we must open "Postman" and copy the url with the Endpoint. Then selecting the action in "POST", we enter the "body", "raw" and options in "Json".

Once the data that we want to add to the database has been loaded, we click on "Send".

We can copy the Json of the result of having executed the Get method in another window.


------------------------------------------------------------------------------------



https://learn.microsoft.com/en-us/aspnet/core/tutorials/min-web-api?view=aspnetcore-6.0&tabs=visual-studio

https://davidcasr.medium.com/herramientas-de-testeo-de-apis-e376b2ffaa5f


Extensions :

https://marketplace.visualstudio.com/items?itemName=kreativ-software.csharpextensions

https://marketplace.visualstudio.com/items?itemName=ms-dotnettools.csharp